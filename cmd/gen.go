package cmd

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"os"
	"sort"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/arr-ai/wbnf/parser"

	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/wbnf"
	"github.com/urfave/cli"
)

var pkgName string
var outFile string
var genCommand = cli.Command{
	Name:    "gen",
	Aliases: []string{"g"},
	Usage:   "Generate a grammar",
	Action:  gen,
	Flags: []cli.Flag{
		cli.StringFlag{
			Name:        "grammar",
			Usage:       "input grammar file",
			Required:    true,
			TakesFile:   true,
			Destination: &inGrammarFile,
		},
		cli.StringFlag{
			Name:        "pkg",
			Usage:       "name of the generated package",
			Required:    true,
			TakesFile:   false,
			Destination: &pkgName,
		},
		cli.StringFlag{
			Name:        "start",
			Usage:       "grammar rule to being parsing at",
			Required:    true,
			TakesFile:   false,
			Destination: &startingRule,
		},
		cli.StringFlag{
			Name:        "output",
			Usage:       "filename to write the output to",
			Required:    false,
			TakesFile:   false,
			Destination: &outFile,
		},
	},
}

func gen(c *cli.Context) error {
	g := loadTestGrammar()
	tree := g.Node().(wbnf.GrammarNode).Node

	root := goNode{name: "parser.Grammar", scope: squigglyScope}

	for _, stmt := range tree.Many("stmt") {
		if p := stmt.One("prod"); p != nil {
			root.Add(*makeProd(p))
		}
	}

	text := fmt.Sprintf(`// Code generated by "Ï‰BNF gen" DO NOT EDIT.
// $ wbnf %s
package %s

import (
	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/parser"
)

func Grammar() parser.Parsers {
	return %s.Compile(nil)
}

type Stopper interface {
	 ExitNode() bool
	 Abort() bool
}
type nodeExiter struct{}
func (n *nodeExiter) ExitNode() bool {return true }
func (n *nodeExiter) Abort() bool {return false }

type aborter struct{}
func (n *aborter) ExitNode() bool {return true }
func (n *aborter) Abort() bool {return true }

%s

%s
`, strings.Join(os.Args[1:], " "), pkgName, root.String(), makeContextTypes(tree), makeExternalApiFuncs(startingRule))

	out, err := format.Source([]byte(text))
	if err != nil {
		fmt.Println(err, root.String())
	}

	switch outFile {
	case "", "-":
		os.Stdout.Write(out)
	default:
		ioutil.WriteFile(outFile, out, 0644)
	}

	return nil
}

const (
	noScope int = iota
	bracesScope
	squigglyScope
	mapScope
)

type goNode struct {
	name     string
	children []goNode
	scope    int
}

func (g *goNode) String() string {
	x := map[int]struct {
		open  string
		close string
	}{
		noScope:       {"", ""},
		mapScope:      {":", ""},
		bracesScope:   {"(", ")"},
		squigglyScope: {"{", "}"},
	}[g.scope]
	children := make([]string, 0, len(g.children))
	for _, c := range g.children {
		children = append(children, c.String())
	}
	return strings.Join([]string{g.name, x.open, strings.Join(children, ",\n"), x.close}, "")
}

func (g *goNode) Add(n goNode) {
	g.children = append(g.children, n)
}

func safeString(src string) string {
	r := strings.NewReplacer("`", "`+\"`\"+`", " ", "", "\n", "")
	return r.Replace(src)
}

func makeAtom(node ast.Node) *goNode {
	atom := node.(ast.Branch)
	x, _ := ast.Which(atom, wbnf.IdentRE, wbnf.IdentSTR, wbnf.IdentIDENT, wbnf.IdentREF, wbnf.IdentTerm)
	name := ""
	switch x {
	case wbnf.IdentTerm, "":
	case wbnf.IdentREF:
		name = safeString(atom.One(x).One(wbnf.IdentIDENT).Scanner().String())
	default:
		name = safeString(atom.One(x).Scanner().String())
	}
	switch x {
	case wbnf.IdentIDENT:
		return &goNode{name: fmt.Sprintf("parser.Rule(`%s`)", name)}
	case wbnf.IdentSTR:
		return &goNode{name: fmt.Sprintf("parser.S(%s)", name)}
	case wbnf.IdentRE:
		if strings.HasPrefix(name, "/{") {
			name = name[2 : len(name)-1]
		}
		return &goNode{name: fmt.Sprintf("parser.RE(`%s`)", name)}
	case wbnf.IdentREF:
		return &goNode{name: fmt.Sprintf("parser.REF(`%s`)", name)}
	case wbnf.IdentTerm:
		return makeTerm(atom.One(x))
	}
	return &goNode{name: "todo"}
}
func makeNamed(node ast.Node) *goNode {
	named := node.(ast.Branch)
	atom := makeAtom(named.One("atom"))

	if named.One(wbnf.IdentIDENT) != nil {
		val := &goNode{name: "parser.Eq",
			scope:    bracesScope,
			children: []goNode{{name: "\"" + named.One(wbnf.IdentIDENT).Scanner().String() + "\""}, *atom},
		}
		return val
	}
	return atom
}
func makeQuant(node ast.Node, term goNode) *goNode {
	switch node.Many(ast.ChoiceTag)[0].(ast.Extra).Data.(parser.Choice) {
	case 0:
		switch node.One("op").Scanner().String() {
		case "*":
			return &goNode{name: "parser.Any", scope: bracesScope, children: []goNode{term}}
		case "?":
			return &goNode{name: "parser.Opt", scope: bracesScope, children: []goNode{term}}
		case "+":
			return &goNode{name: "parser.Some", scope: bracesScope, children: []goNode{term}}
		}
	case 1:
		min := "0"
		max := "0"
		if x := node.One("min"); x != nil {
			min = x.Scanner().String()
		}
		if x := node.One("max"); x != nil {
			max = x.Scanner().String()
		}
		term.name = "Term: " + term.name
		return &goNode{name: "parser.Quant", scope: squigglyScope, children: []goNode{term, {name: "Min:" + min}, {name: "Max:" + max}}}
	case 2:
		delim := &goNode{name: "parser.Delim", scope: squigglyScope}
		var assoc string
		switch node.One("op").Scanner().String() {
		case "<:":
			assoc = "Assoc: parser.RightToLeft"
		case ":>":
			assoc = "Assoc: parser.LeftToRight"
		default:
			assoc = "Assoc: parser.NonAssociative"
		}
		term.name = "Term: " + term.name
		sep := *makeNamed(node.One("named"))
		sep.name = "Sep: " + sep.name
		delim.children = []goNode{term, sep, {name: assoc}}
		if node.One("opt_leading") != nil {
			delim.children = append(delim.children, goNode{name: "CanStartWithSep: true"})
		}
		if node.One("opt_trailing") != nil {
			delim.children = append(delim.children, goNode{name: "CanEndWithSep: true"})
		}
		return delim
	}
	return &goNode{name: "todo"}
}

func makeTerm(node ast.Node) *goNode {
	term := node.(ast.Branch)
	x, _ := ast.Which(term, "term", "atom", "named")
	switch x {
	case "term":
		var next *goNode
		if ops := term.Many("op"); len(ops) > 0 {
			switch ops[0].Scanner().String() {
			case "|":
				next = &goNode{name: "parser.Oneof", scope: squigglyScope}
			case ">":
				next = &goNode{name: "parser.Stack", scope: squigglyScope}
			}
		} else {
			next = &goNode{name: "parser.Seq", scope: squigglyScope}
		}
		for _, t := range term.Many("term") {
			next.Add(*makeTerm(t))
		}
		if len(next.children) == 1 {
			return &next.children[0]
		}
		return next
	case "named":
		// named and quants need to be added backwards
		// "a":","*     ->   Any(Delim(... S("a")))
		next := makeNamed(term.One("named"))
		quants := term.Many("quant")
		for i := range quants {
			next = makeQuant(quants[len(quants)-1-i], *next)
		}
		return next
	}
	return &goNode{name: "todo"}
}

func makeProd(tree ast.Node) *goNode {
	terms := tree.Many("term")

	p := &goNode{
		name: fmt.Sprintf(`"%s"`,
			tree.One("IDENT").Scanner().String()),
		children: nil,
		scope:    mapScope,
	}
	for _, t := range terms {
		p.Add(*makeTerm(t))
	}
	return p
}

const typefunctemplate = `

func (c {{.CtxName}}) All{{.ChildName}}() []{{.RetType}} {
	var out []{{.RetType}}
	for _, child := range ast.All(c.Node, "{{.Child}}") {
		out = append(out, {{.RetType}}{child})
	}
	return out
}

func (c {{.CtxName}}) One{{.ChildName}}() {{.RetType}} {
	return {{.RetType}}{ast.First(c.Node, "{{.Child}}")}
}
`

const tokenGetterTemplate = `
func (c {{.CtxName}}) All{{.ChildName}}() []string {
	var out []string
	for _, child := range ast.All(c.Node, "{{.Child}}") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c {{.CtxName}}) One{{.ChildName}}() string {
	if child := ast.First(c.Node, "{{.Child}}"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}
`

type tmplData struct {
	CtxName   string
	Child     string
	ChildName string
	RetType   string
}

func sortMapKeys(m map[string][]string) []string {
	keys := make([]string, 0, len(m))
	for rule := range m {
		keys = append(keys, rule)
	}
	sort.Strings(keys)
	return keys
}

func makeContextTypes(tree ast.Node) string {
	out := bytes.Buffer{}
	tmpl, err := template.New("funcs").Parse(typefunctemplate)
	if err != nil {
		panic(err)
	}
	tokentmpl, err := template.New("token").Parse(tokenGetterTemplate)
	if err != nil {
		panic(err)
	}

	var walkerOpsBuf bytes.Buffer
	walkerOpsBuf.WriteString("\ntype WalkerOps struct {\n")

	// generate the ident string consts
	out.WriteString("const ( \n")
	for _, id := range wbnf.Idents(tree.(ast.Branch)) {
		if id == ast.ChoiceTag || id == "@" {
			continue
		} else if strings.Contains(id, "@") {
			id = strings.Split(id, "@")[0]
		}
		out.WriteString("Ident" + strcase.ToCamel(id) + " = \"" + id + "\"\n")
	}
	out.WriteString(")\n")

	allIdents := wbnf.IdentMap(tree.(ast.Branch))
	for _, rule := range sortMapKeys(allIdents) {
		idents := allIdents[rule]
		typename := strcase.ToCamel(strings.ToLower(rule) + "Node")
		out.WriteString(fmt.Sprintf("type %s struct { ast.Node} \n", typename))
		if len(idents) == 0 {
			out.WriteString(fmt.Sprintf(`
func (c %s) String() string {
	if c.Node == nil { return "" }
	return ast.First(c.Node, "").Scanner().String()
}
`, typename))
		}
		// walker func start
		var walkerbuf bytes.Buffer
		walkerbuf.WriteString(strings.ReplaceAll(`func Walk{{.CtxName}}(node {{.CtxName}}, ops WalkerOps) Stopper {
	if fn := ops.Enter{{.CtxName}}; fn != nil {
		s := fn(node)
		switch {
			case s == nil:
			case s.ExitNode():
				return nil
			case s.Abort():
				return s
		}
}
`, "{{.CtxName}}", typename))

		walkerOpsBuf.WriteString(strings.ReplaceAll("Enter{{.CtxName}} func ({{.CtxName}}) Stopper\n", "{{.CtxName}}", typename))
		walkerOpsBuf.WriteString(strings.ReplaceAll("Exit{{.CtxName}} func ({{.CtxName}}) Stopper\n", "{{.CtxName}}", typename))

		for _, id := range idents {
			if id == "@" {
				id = rule
			} else if id == ast.ChoiceTag {
				out.WriteString(fmt.Sprintf(`
func (c %s) Choice() int {
	return ast.Choice(c.Node)
}
`, typename))
				continue
			}
			data := tmplData{
				CtxName:   typename,
				Child:     id,
				ChildName: strcase.ToCamel(strings.ToLower(id)),
				RetType:   strcase.ToCamel(strings.ToLower(id)) + "Node",
			}

			if strings.Contains(id, "@") {
				parts := strings.Split(id, "@")
				data.Child = parts[0]
				data.ChildName = strcase.ToCamel(parts[0])
				if len(parts) == 1 || parts[1] == "" {
					tokentmpl.Execute(&out, data)
					continue
				}
				data.RetType = strcase.ToCamel(strings.ToLower(parts[1])) + "Node"
			}
			tmpl.Execute(&out, data)
			if !strings.Contains(id, "@") {
				text := strings.ReplaceAll(`
for _, child := range node.All{{}}() {
	s := Walk{{}}Node(child, ops)
		switch {
			case s == nil:
			case s.ExitNode():
				return nil
			case s.Abort():
				return s
		}
}`, "{{}}",
					data.ChildName)
				walkerbuf.WriteString(text)
			}
		}

		walkerbuf.WriteString(strings.ReplaceAll(`
if fn := ops.Exit{{.CtxName}}; fn != nil {
	if s := fn(node); s != nil && s.Abort() { return s }
}
	return nil
}
`,
			"{{.CtxName}}", typename))
		out.Write(walkerbuf.Bytes())
	}

	walkerOpsBuf.WriteString("\n}\n")
	out.Write(walkerOpsBuf.Bytes())

	return out.String()
}

func makeExternalApiFuncs(startRule string) string {
	tmpl := `
func (w WalkerOps) Walk(tree {{.CtxName}}) { Walk{{.CtxName}}(tree, w) }
func (c {{.CtxName}}) GetAstNode() ast.Node { return c.Node }

func New{{.CtxName}}(from ast.Node) {{.CtxName}} { return {{.CtxName}}{ from } }

func Parse(input *parser.Scanner) ({{.CtxName}}, error) {
	p := Grammar()
	tree, err := p.Parse("{{startrule}}", input)
	if err != nil {
		return {{.CtxName}}{nil}, err
	}
	return {{.CtxName}}{ast.FromParserNode(p.Grammar(), tree)}, nil
}

func ParseString(input string) ({{.CtxName}}, error) {
	return Parse(parser.NewScanner(input))
}`
	return strings.NewReplacer("{{.CtxName}}", strcase.ToCamel(startRule)+"Node",
		"{{startrule}}", startRule).Replace(tmpl)
}
