package cmd

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"os"
	"sort"
	"strings"

	"github.com/arr-ai/wbnf/cmd/codegen"

	"github.com/iancoleman/strcase"

	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/wbnf"
	"github.com/urfave/cli"
)

var pkgName string
var outFile string
var genCommand = cli.Command{
	Name:    "gen",
	Aliases: []string{"g"},
	Usage:   "Generate a grammar",
	Action:  gen,
	Flags: []cli.Flag{
		cli.StringFlag{
			Name:        "grammar",
			Usage:       "input grammar file",
			Required:    true,
			TakesFile:   true,
			Destination: &inGrammarFile,
		},
		cli.StringFlag{
			Name:        "pkg",
			Usage:       "name of the generated package",
			Required:    true,
			TakesFile:   false,
			Destination: &pkgName,
		},
		cli.StringFlag{
			Name:        "start",
			Usage:       "grammar rule to being parsing at",
			Required:    true,
			TakesFile:   false,
			Destination: &startingRule,
		},
		cli.StringFlag{
			Name:        "output",
			Usage:       "filename to write the output to",
			Required:    false,
			TakesFile:   false,
			Destination: &outFile,
		},
	},
}

func gen(c *cli.Context) error {
	g := loadTestGrammar()
	tree := g.Node().(wbnf.GrammarNode).Node

	root := codegen.MakeGrammar(tree)

	text := fmt.Sprintf(`// Code generated by "Ï‰BNF gen" DO NOT EDIT.
// $ wbnf %s
package %s

import (
	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/parser"
)

func Grammar() parser.Parsers {
	return %s.Compile(nil)
}

type Stopper interface {
	 ExitNode() bool
	 Abort() bool
}
type nodeExiter struct{}
func (n *nodeExiter) ExitNode() bool {return true }
func (n *nodeExiter) Abort() bool {return false }

type aborter struct{}
func (n *aborter) ExitNode() bool {return true }
func (n *aborter) Abort() bool {return true }

%s

%s
`, strings.Join(os.Args[1:], " "), pkgName, root.String(), makeContextTypes(tree), makeExternalApiFuncs(startingRule))

	out, err := format.Source([]byte(text))
	if err != nil {
		fmt.Println(err, root.String())
	}

	switch outFile {
	case "", "-":
		os.Stdout.Write(out)
	default:
		ioutil.WriteFile(outFile, out, 0644)
	}

	return nil
}

const typefunctemplate = `

func (c {{.CtxName}}) All{{.ChildName}}() []{{.RetType}} {
	var out []{{.RetType}}
	for _, child := range ast.All(c.Node, "{{.Child}}") {
		out = append(out, {{.RetType}}{child})
	}
	return out
}

func (c {{.CtxName}}) One{{.ChildName}}() {{.RetType}} {
	return {{.RetType}}{ast.First(c.Node, "{{.Child}}")}
}
`

const tokenGetterTemplate = `
func (c {{.CtxName}}) All{{.ChildName}}() []string {
	var out []string
	for _, child := range ast.All(c.Node, "{{.Child}}") {
		out = append(out, ast.First(child, "").Scanner().String())
	}
	return out
}

func (c {{.CtxName}}) One{{.ChildName}}() string {
	if child := ast.First(c.Node, "{{.Child}}"); child != nil {
		return ast.First(child, "").Scanner().String()
	}
	return ""
}
`

type tmplData struct {
	CtxName   string
	Child     string
	ChildName string
	RetType   string
}

func sortMapKeys(m map[string][]string) []string {
	keys := make([]string, 0, len(m))
	for rule := range m {
		keys = append(keys, rule)
	}
	sort.Strings(keys)
	return keys
}

func makeContextTypes(tree ast.Node) string {
	out := bytes.Buffer{}
	tmpl, err := template.New("funcs").Parse(typefunctemplate)
	if err != nil {
		panic(err)
	}
	tokentmpl, err := template.New("token").Parse(tokenGetterTemplate)
	if err != nil {
		panic(err)
	}

	var walkerOpsBuf bytes.Buffer
	walkerOpsBuf.WriteString("\ntype WalkerOps struct {\n")

	// generate the ident string consts
	out.WriteString("const ( \n")
	for _, id := range wbnf.Idents(tree.(ast.Branch)) {
		if id == ast.ChoiceTag || id == "@" {
			continue
		} else if strings.Contains(id, "@") {
			id = strings.Split(id, "@")[0]
		}
		out.WriteString("Ident" + strcase.ToCamel(id) + " = \"" + id + "\"\n")
	}
	out.WriteString(")\n")

	allIdents := wbnf.IdentMap(tree.(ast.Branch))
	for _, rule := range sortMapKeys(allIdents) {
		idents := allIdents[rule]
		typename := strcase.ToCamel(strings.ToLower(rule) + "Node")
		out.WriteString(fmt.Sprintf("type %s struct { ast.Node} \n", typename))
		if len(idents) == 0 {
			out.WriteString(fmt.Sprintf(`
func (c %s) String() string {
	if c.Node == nil { return "" }
	return c.Node.Scanner().String()
}
`, typename))
		}
		// walker func start
		var walkerbuf bytes.Buffer
		walkerbuf.WriteString(strings.ReplaceAll(`func Walk{{.CtxName}}(node {{.CtxName}}, ops WalkerOps) Stopper {
	if fn := ops.Enter{{.CtxName}}; fn != nil {
		s := fn(node)
		switch {
			case s == nil:
			case s.ExitNode():
				return nil
			case s.Abort():
				return s
		}
}
`, "{{.CtxName}}", typename))

		walkerOpsBuf.WriteString(strings.ReplaceAll("Enter{{.CtxName}} func ({{.CtxName}}) Stopper\n", "{{.CtxName}}", typename))
		walkerOpsBuf.WriteString(strings.ReplaceAll("Exit{{.CtxName}} func ({{.CtxName}}) Stopper\n", "{{.CtxName}}", typename))

		for _, id := range idents {
			if id == "@" {
				id = rule
			} else if id == ast.ChoiceTag {
				out.WriteString(fmt.Sprintf(`
func (c %s) Choice() int {
	return ast.Choice(c.Node)
}
`, typename))
				continue
			}
			data := tmplData{
				CtxName:   typename,
				Child:     id,
				ChildName: strcase.ToCamel(strings.ToLower(id)),
				RetType:   strcase.ToCamel(strings.ToLower(id)) + "Node",
			}

			if strings.Contains(id, "@") {
				parts := strings.Split(id, "@")
				data.Child = parts[0]
				data.ChildName = strcase.ToCamel(parts[0])
				if len(parts) == 1 || parts[1] == "" {
					tokentmpl.Execute(&out, data)
					continue
				}
				data.RetType = strcase.ToCamel(strings.ToLower(parts[1])) + "Node"
			}
			tmpl.Execute(&out, data)
			if !strings.Contains(id, "@") {
				text := strings.ReplaceAll(`
for _, child := range node.All{{}}() {
	s := Walk{{}}Node(child, ops)
		switch {
			case s == nil:
			case s.ExitNode():
				return nil
			case s.Abort():
				return s
		}
}`, "{{}}",
					data.ChildName)
				walkerbuf.WriteString(text)
			}
		}

		walkerbuf.WriteString(strings.ReplaceAll(`
if fn := ops.Exit{{.CtxName}}; fn != nil {
	if s := fn(node); s != nil && s.Abort() { return s }
}
	return nil
}
`,
			"{{.CtxName}}", typename))
		out.Write(walkerbuf.Bytes())
	}

	walkerOpsBuf.WriteString("\n}\n")
	out.Write(walkerOpsBuf.Bytes())

	return out.String()
}

func makeExternalApiFuncs(startRule string) string {
	tmpl := `
func (w WalkerOps) Walk(tree {{.CtxName}}) { Walk{{.CtxName}}(tree, w) }
func (c {{.CtxName}}) GetAstNode() ast.Node { return c.Node }

func New{{.CtxName}}(from ast.Node) {{.CtxName}} { return {{.CtxName}}{ from } }

func Parse(input *parser.Scanner) ({{.CtxName}}, error) {
	p := Grammar()
	tree, err := p.Parse("{{startrule}}", input)
	if err != nil {
		return {{.CtxName}}{nil}, err
	}
	return {{.CtxName}}{ast.FromParserNode(p.Grammar(), tree)}, nil
}

func ParseString(input string) ({{.CtxName}}, error) {
	return Parse(parser.NewScanner(input))
}`
	return strings.NewReplacer("{{.CtxName}}", strcase.ToCamel(startRule)+"Node",
		"{{startrule}}", startRule).Replace(tmpl)
}
