package parser

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/arr-ai/frozen"

	"github.com/arr-ai/wbnf/errors"
)

func NodeRule(e Node) Rule {
	return Rule(e.Tag)
}

type Grammar map[Rule]Term

// Unparse inverts the action of a parser, taking a generated AST and producing
// the source it came from. Currently, it doesn't quite do that, and is only
// being used for quick eyeballing to validate output.
func (g Grammar) Unparse(e TreeElement, w io.Writer) (n int, err error) {
	rule := NodeRule(e.(Node))
	return g[rule].Unparse(g, e, w)
}

// Parsers holds Parsers generated by Grammar.Compile.
type Parsers struct {
	parsers map[Rule]Parser
	grammar Grammar
	node    interface{}
}

func (p Parsers) Grammar() Grammar {
	return p.grammar
}

func (p Parsers) Node() interface{} {
	return p.node
}

func (p Parsers) HasRule(rule Rule) bool {
	_, has := p.parsers[rule]
	return has
}

func (p Parsers) Unparse(e TreeElement, w io.Writer) (n int, err error) {
	return p.grammar.Unparse(e, w)
}

// Parse parses some source per a given rule.
func (p Parsers) Parse(rule Rule, input *Scanner) (TreeElement, error) {
	start := *input
	for {
		var e TreeElement
		if err := p.parsers[rule].Parse(frozen.NewMap(), input, &e); err != nil {
			return nil, err
		}

		if input.String() == "" {
			return e, nil
		}

		if input.Offset() == start.Offset() {
			return nil, fmt.Errorf("unconsumed input: %v", input.Context())
		}
	}
}

// MustParse calls Parse and returns the result or panics if an error was
// returned.
func (p Parsers) MustParse(rule Rule, input *Scanner) TreeElement {
	i, err := p.Parse(rule, input)
	if err != nil {
		panic(err)
	}
	return i
}

// Term represents the terms of a grammar specification.
type Term interface {
	fmt.Stringer
	Parser(name Rule, c cache) Parser
	Unparse(g Grammar, e TreeElement, w io.Writer) (n int, err error)
	Resolve(oldRule, newRule Rule) Term
}

type Choice int

func (Choice) IsExtra() {}

type Associativity int

func NewAssociativity(s string) Associativity {
	switch s {
	case ":":
		return NonAssociative
	case ":>":
		return LeftToRight
	case "<:":
		return RightToLeft
	}
	panic(errors.BadInput)
}

func (Associativity) IsExtra() {}

func (a Associativity) String() string {
	switch {
	case a < 0:
		return "<:"
	case a > 0:
		return ":>"
	}
	return ":"
}

const (
	RightToLeft Associativity = iota - 1
	NonAssociative
	LeftToRight
)

type (
	Rule string
	S    string
	RE   string
	REF  struct {
		Ident   string
		Default Term
	}
	Seq   []Term
	Oneof []Term
	Stack []Term
	Delim struct {
		Term            Term
		Sep             Term
		Assoc           Associativity
		CanStartWithSep bool
		CanEndWithSep   bool
	}
	Quant struct {
		Term Term
		Min  int
		Max  int // 0 = infinity
	}
	Named struct {
		Name string
		Term Term
	}
	ScopedGrammar struct {
		Term    Term
		Grammar Grammar
	}
	CutPoint struct{ Term }
)

func NonAssoc(term, sep Term) Delim { return Delim{Term: term, Sep: sep, Assoc: NonAssociative} }
func L2R(term, sep Term) Delim      { return Delim{Term: term, Sep: sep, Assoc: LeftToRight} }
func R2L(term, sep Term) Delim      { return Delim{Term: term, Sep: sep, Assoc: RightToLeft} }

func Opt(term Term) Quant  { return Quant{Term: term, Max: 1} }
func Any(term Term) Quant  { return Quant{Term: term} }
func Some(term Term) Quant { return Quant{Term: term, Min: 1} }

func Eq(name string, term Term) Named {
	return Named{Name: name, Term: term}
}

func join(terms []Term, sep string) string {
	s := []string{}
	for _, t := range terms {
		s = append(s, t.String())
	}
	return strings.Join(s, sep)
}

func (t Quant) Contains(i int) bool {
	return t.Min <= i && !t.MaxLessThan(i)
}

func (t Quant) MaxLessThan(i int) bool {
	return t.Max > 0 && t.Max < i
}

func (g Grammar) String() string {
	keys := make([]string, 0, len(g))
	for key := range g {
		keys = append(keys, string(key))
	}
	sort.Strings(keys)

	var sb strings.Builder
	count := 0
	for _, key := range keys {
		if count > 0 {
			sb.WriteString("; ")
		}
		fmt.Fprintf(&sb, "%s -> %v", key, g[Rule(key)])
		count++
	}
	if count > 1 {
		sb.WriteString(";")
	}
	return sb.String()
}

func (t Rule) String() string     { return string(t) }
func (t S) String() string        { return fmt.Sprintf("%q", string(t)) }
func (t RE) String() string       { return fmt.Sprintf("/%v/", string(t)) }
func (t REF) String() string      { return fmt.Sprintf("%%%v=%v", t.Ident, t.Default) }
func (t Seq) String() string      { return "(" + join(t, " ") + ")" }
func (t Oneof) String() string    { return join(t, " | ") }
func (t Stack) String() string    { return join(t, " > ") }
func (t Named) String() string    { return fmt.Sprintf("%s=%v", t.Name, t.Term) }
func (t CutPoint) String() string { return fmt.Sprintf("cutpoint {%s}", t.Term.String()) }

func (t Delim) String() string {
	leading := ""
	if t.CanStartWithSep {
		leading = ","
	}
	trailing := ""
	if t.CanEndWithSep {
		trailing = ","
	}
	return fmt.Sprintf("%v%s%s%v%s", t.Term, t.Assoc, leading, t.Sep, trailing)
}

func (t Quant) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "%v", t.Term)
	switch [2]int{t.Min, t.Max} {
	case [2]int{0, 0}:
		sb.WriteString("*")
	case [2]int{0, 1}:
		sb.WriteString("?")
	case [2]int{1, 0}:
		sb.WriteString("+")
	case [2]int{1, 1}:
		panic(errors.Inconceivable)
	default:
		sb.WriteString("{")
		if t.Min != 0 {
			fmt.Fprintf(&sb, "%d", t.Min)
		}
		sb.WriteString(",")
		if t.Max != 0 {
			fmt.Fprintf(&sb, "%d", t.Max)
		}
		sb.WriteString("}")
	}
	return sb.String()
}

func (t ScopedGrammar) String() string {
	return fmt.Sprintf("%v { %v }", t.Term, t.Grammar)
}
