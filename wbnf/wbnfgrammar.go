// Code generated by "ωBNF gen" DO NOT EDIT.
// $ wbnf gen --grammar ../examples/wbnf.wbnf --rootrule grammar --pkg wbnf
package wbnf

import (
	"github.com/arr-ai/wbnf/ast"
	"github.com/arr-ai/wbnf/parser"
)

func Grammar() parser.Grammar {
	return parser.Grammar{"grammar": parser.Some(parser.Rule(`stmt`)),
		"stmt": parser.Oneof{parser.Rule(`COMMENT`),
			parser.Rule(`prod`)},
		"prod": parser.Seq{parser.Rule(`IDENT`),
			parser.S("->"),
			parser.Some(parser.Rule(`term`)),
			parser.S(";")},
		"term": parser.Stack{parser.Delim{Term: parser.Rule(`@`),
			Sep: parser.Eq("op",
				parser.S(">")),
			Assoc: parser.NonAssociative},
			parser.Delim{Term: parser.Rule(`@`),
				Sep: parser.Eq("op",
					parser.S("|")),
				Assoc: parser.NonAssociative},
			parser.Some(parser.Rule(`@`)),
			parser.Seq{parser.Rule(`named`),
				parser.Any(parser.Rule(`quant`))}},
		"named": parser.Seq{parser.Opt(parser.Seq{parser.Rule(`IDENT`),
			parser.Eq("op",
				parser.S("="))}),
			parser.Rule(`atom`)},
		"quant": parser.Oneof{parser.Eq("op",
			parser.RE(`[?*+]`)),
			parser.Seq{parser.S("{"),
				parser.Opt(parser.Eq("min",
					parser.Rule(`INT`))),
				parser.S(","),
				parser.Opt(parser.Eq("max",
					parser.Rule(`INT`))),
				parser.S("}")},
			parser.Seq{parser.Eq("op",
				parser.RE(`<:|:>?`)),
				parser.Opt(parser.Eq("opt_leading",
					parser.S(","))),
				parser.Rule(`named`),
				parser.Opt(parser.Eq("opt_trailing",
					parser.S(",")))}},
		"atom": parser.Oneof{parser.Rule(`IDENT`),
			parser.Rule(`STR`),
			parser.Rule(`RE`),
			parser.Rule(`REF`),
			parser.Seq{parser.S("("),
				parser.Rule(`term`),
				parser.S(")")},
			parser.Seq{parser.S("("),
				parser.S(")")}},
		"COMMENT": parser.RE(`//.*$|(?s:/\*(?:[^*]|\*+[^*/])\*/)`),
		"IDENT":   parser.RE(`@|[A-Za-z_\.]\w*`),
		"INT":     parser.RE(`\d+`),
		"STR":     parser.RE(`"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*'|` + "`" + `(?:` + "`" + `` + "`" + `|[^` + "`" + `])*` + "`" + ``),
		"RE":      parser.RE(`/{((?:\\.|{(?:(?:\d+(?:,\d*)?|,\d+)\})?|\[(?:\\]|[^\]])+]|[^\\{\}])*)\}`),
		"REF": parser.Seq{parser.S("%"),
			parser.Rule(`IDENT`),
			parser.Opt(parser.Seq{parser.S("="),
				parser.Eq("default",
					parser.Rule(`STR`))})},
		".wrapRE": parser.RE(`\s*()\s*`)}
}

func Parse(input *parser.Scanner) (ast.Node, error) {
	p := Grammar().Compile(nil)
	tree, err := p.Parse("grammar", input)
	if err != nil {
		return nil, err
	}
	return ast.FromParserNode(p.Grammar(), tree), nil
}

func ParseString(input string) (ast.Node, error) {
	return Parse(parser.NewScanner(input))
}

var grammarGrammarSrc = unfakeBackquote(`
// Non-terminals
grammar -> stmt+;
stmt    -> COMMENT | prod;
prod    -> IDENT "->" term+ ";";
term    -> @:op=">"
         > @:op="|"
         > @+
         > named quant*;
named   -> (IDENT op="=")? atom;
quant   -> op=/{[?*+]}
         | "{" min=INT? "," max=INT? "}"
         | op=/{<:|:>?} opt_leading=","? named opt_trailing=","?;
atom    -> IDENT | STR | RE | REF | "(" term ")" | "(" ")";

// Terminals
COMMENT -> /{ //.*$
            | (?s: /\* (?: [^*] | \*+[^*/] ) \*/ )
            };
IDENT   -> /{@|[A-Za-z_\.]\w*};
INT     -> /{\d+};
STR     -> /{ " (?: \\. | [^\\"] )* "
            | ' (?: \\. | [^\\'] )* '
            | ‵ (?: ‵‵  | [^‵]   )* ‵
            };
RE      -> /{
             /{
               ((?:
                 \\.
                 | { (?: (?: \d+(?:,\d*)? | ,\d+ ) \} )?
                 | \[ (?: \\] | [^\]] )+ ]
                 | [^\\{\}]
               )*)
             \}
           };
REF     -> "%" IDENT ("=" default=STR)?;

// Special
.wrapRE -> /{\s*()\s*};
`)
